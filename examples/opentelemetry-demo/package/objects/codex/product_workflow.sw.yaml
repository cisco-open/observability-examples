id: product_workflow
version: '1.0.0'
specVersion: '0.9'
name: product-workflow
description: Workflow to extract product entities and their metrics from logs
events:
  - name: event-received
    type: contracts:cloudevent/platform:event.enriched.v1
    kind: consumed
    source: platform
  - name: entity-observed
    type: contracts:cloudevent/platform:entity.observed.v1
    kind: produced
  - name: measurement-observed
    type: contracts:cloudevent/platform:measurement.received.v1
    kind: produced
functions:
  - name: map-input
    type: expression
    operation: >
      {'attributes': data.attributes, 'timestamp': data.timestamp}
  - name: create-observations
    type: expression
    operation: |-
      (
        /* $product := $createEntity(productEntityType, timestamp, {'product.id': attributes.productId}); */
        $product := $createEntity({ 'entityType': 'opentelemetrydemo:product', 'attributes': {'product.id': attributes.productId} });
        $measurement := {
            'entity': {
              'id': $product.id,
              'type': $product.type
            },
            /* 'type': cartMetricType, */
            'type': 'opentelemetrydemo:cart.products.total',
            'attributes': {
              'user.id': attributes.userId
            },
            'measurements': [
              {
                'timestamp': timestamp,
                'intValue': attributes.quantity
              }
            ]
        };
      
        {
          'entity': $product ~> |$|{'observedAt': $$.timestamp}|,
          'measurement': $measurement
        }
      )
states:
  - name: filter-traces
    type: event
    onEvents:
      - eventRefs:
          - event-received
    stateDataFilter:
      output: ${ fn:map-input }
    transition: filter
  - name: filter
    type: switch
    dataConditions:
      - name: match
        condition: ${ $exists(attributes.productId) }
        transition: consume-event
    #        transition: set-types
    defaultCondition:
      end: true
  #  - name: set-types
  #    type: inject
  #    data:
  #      # sets the type of the observed entities while keeping solution identifier dynamic, which allows to rename the solution without any modifications to this workflow
  #      productEntityType: >
  #        @INSTALL ${$sys.solutionId & ':product'}
  #      cartMetricType: >
  #        @INSTALL ${$sys.solutionId & ':cart.products.total'}
  #    transition: consume-event
  - name: consume-event
    type: operation
    actions:
      - name: create-observations
        functionRef: create-observations
    stateDataFilter:
      output: ${ $ ~> |$|{},['attributes','timestamp']| }
    end:
      terminate: true
      produceEvents:
        - eventRef: entity-observed
          data: ${ entity }
        - eventRef: measurement-observed
          data: ${ measurement }
